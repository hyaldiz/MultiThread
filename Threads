
#include <unistd.h>   sleep vb fonksiyonlar için
#include <pthreads.h> thread fonksiyonları için


1-) THREAD OLUŞTURMA

*-* int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                          void *(*start_routine) (void *), void *arg); 
       --> Thread oluşturmamızı sağlar.

	NOT: Threadlerin stackleri farklıdır.
	
2-) THREAD ID'LERININ ALINMASI

*-* pthread_t pthread_self(void);   -> Çağrıldığı thread'te thread'in id'sini döndürür
	
	örn;
	pthread_t tid1 = pthread_self(void);
	
	zaten task create yapılırken arguman olarak verilen &id'yle aynı
	main'inde thread id si vardır.

3-) THREAD SONLANDIRMA

	-->Process'i sonlandırırsak tüm threadler sonlanır.
	-->exit() kullanılarak process sonlanacağından thredler de sonlanacaktır.
	   Return le sonlandırılabilir ve BUNA THREAD'IN EXIT KODU DENIR. Bir Thread diğer thread'i
	   sonlandırabilir.
        -->pthread_exit(); fonksiyonu ile sonlandırılabilir.

*-* void pthread_exit(void *retval);

	örn; pthread_exit((void*)123);
	
	örn; return (void*)450; (thredin return kısmına)
	
	örn; exit(...); (direk process sonlanır duruma göre istediğin yerde kullan)
	
4-) BIR THREAD'IN BAŞKA BİR THREAD'İ SONLANDIRMASI

	*-* int pthread_cancel(pthread_t thread); (thred'i sonlandırma istediğinde bulunur. Kesin sonlandıracak diye bir durum yok)
		->Başarı durumunda 0 döndürür.
		
		örn; herhangi bir thread'e ait id = thd1_id
		
		pthread_cancel(thd1_id);
		
		NOT: printf vb cancelation point göremezse thread'i sonlandırmaz!!!!!!
		     mesela programda uzun bir döngünün içne null statement koyduk altına join koyduk ama thread sonlanmadı. CANCELATION POINT GORMESI LAZIM.
		     
		 GOOGLE'DA pthread_cancel() FONKSIYONUNU ARATARAK BU CANCELATION POINTS FONKSIYONLARINA BAKABILIRSIN.
		 
		 
 5-) THREADLERIN BEKLETILMESI VE DETACH DURUMU
 
 	 --> pthread_join yazıldığı yerde thread'in bitmesini bekler ve thread bitince devam eder. Akışı yazıldığı yere sabitler.
 	 
 	 *-* int pthread_join(pthread_t thread , void **retval);  //2. parametreyle thread'in geri dönüş değerini alabiliriz.
 	     başarı durumunda 0 başarısızlık durumunda non-zero bir değer döndürür. 
 	     
 	     örn; pthread_join(tid1,NULL); //thread joinden sonra biter ve cpu zamanı harcamaz
 	     
 	     NOT: pointer to pointer demek bir pointer'in adresini istiyor demek.
 	     
 	     örn; void *thread_exit_code;
 	     
 	     pthread_join(tid1,&thread_exit_code);
 	     printf("worker thread exit code:%p\n",thread_exit_code);
 	     
 	     
 	     
	NOT:BIR THREAD BAŞKA BIR THREADI SONLANDIRIRSA pthread_cancel'la ""PTHREAD_CANCELED"" MACROSU SET OLUR VE BU MACROYU KULLANARAK TESPIT YAPABILIRIZ. (-1) thread'in döönüş değeri -1 olur ce macroda -1'e setlenir!!!
		
		pthread_cancel(thd_id_x);	//kullanılırsa  1'e kullanılmazsa 2
	
	     if(thread_exit_code == PTHREAD_CANCELED)
	     	printf("with pthread_canceled\n");		//1
     	     else
     	     	printf("without pthread_cancel\n");		//2
     	     	
     	     	
	*-* int pthread_detach(pthread_t thread); (başarı durumunda sıfır başarısızlık durumunda non-zero değer döndürür.)
	
	örn; pthread_detach(thd_id_x);
	     
	     NOT: Hangi durumda kullanılır-> thread'in geri dönüş değeriyle ilgilenmiyorsak ve join yapmayacaksak thread'in bitmesi beklenmez program sonlandığında thread'de direk sonlanır ve tüm kaynakları iade edilsin sistemi boş yere meşgul etmesin diyoruz thred'i detach duruma sokmak bu anlama gelir.
	     NOT:detach edilmiş bir thread'e join yaparsak başarısız olur.
	     
6-) THREAD SENKRONIZASYONU

	2 task yazma-yazma
	2 task yazma-okuma vb. aklına gelsin
	Bağlı liste örneği
	önemlidir bu senkronizasyonu sağlamak için mutex kullanacağız.
	
7-)MUTEX (Mutual Exclusion)

	-->diğer tasklar mutex'i alamazsa kendini wait kuyruğuna alır.
	
		mutex-var;
			lock(mutex-var);
			cmd;
			cmd;
			unlock(mutex-var);
			
	--> RTOS'taki task enter critical ve semaphore
	
	
	mutex oluşturma;
		öncelikle mutex nesnesi global olmak zorundadır. çünkü threadler aynı mutex değişkenini açıp kapatacaktır.
		
		pthread_mutex_t g_mutex; //global
		
		
		NOT:mutex tasklar create yapılmadan önce oluşturulmalı -> sebebi tasklar direk başlar ve mutex olmadığı için senkronizasyon bozulur.
		
	*-* int pthread_mutex_init(pthread_mutex_t *__mutex,
			       const pthread_mutexattr_t *__mutexattr); (başarı durumunda sıfır döndürür. Başarısızlık durumunda ERROR NUMBER döndürür.)
			       
        *-* int pthread_mutex_lock(pthread_mutex_t *__mutex); (mutex'i lock yapar başarı->0 başarısız ERROR NUMBER)
        *-* int pthread_mutex_unlock(pthread_mutex_t *__mutex); (mutex'i unlock yapar başarı->0 başarısız ERROR NUMBER)
        
        !!!NOT!!! = mutex pthread_mutex_init(); API'ı kullnamadan da init edilebilir.
        	örn; global olarak tanımlanan pthread_mutex_t g_mutex = PTHREAD_MUTEX_INITIALIZER; macrosu kullanılarak ta mutex init edilebilir(buna static initialize denir.).
        	
	NOT: mutex'i alamayan thread'ler bloke olur ve wait kuyruğunda beklerler.
        	
        	
	*-* int pthread_mutex_trylock(pthread_mutex_t *mutex); (başarı ->0 başarısız->ERROR NUMBER)
	
		->trylock fonksiyonu block modda beklemek yerine başka iş yapar nasıl yani.
			
			if(trylock==0)
			{	//mutex lock durumunda değilse bu kısmı yürütür.
				cmd
				cmd
				unlock
			}
			else	//eğer mutex lock duurmdaysa bu kısmı yapar.
			{
				cmd
				cmd
			}
			
8-)DEADLOCK

	->threadlerin birbirini kilitleyip devam edememesi durumu
	
	örn;
	THREAD1
		l->t1
		sleep(1);	//sleep koyulmasa problem yok gibi ama bu olmayacağı anlamına gelmez çok tehlikeli
		l->t2
		CMD
		ul->t1
		ul->t2
		
	THREAD2
		l->t2
		l->t1
		CMD
		ul->t2
		ul->t1
		
		
	DEADLOCK ÇÖZÜMÜ
	
	THREAD1
		l->t1
		sleep(1);	//sleep koyulmasa problem yok gibi ama bu olmayacağı anlamına gelmez çok tehlikeli
		l->t2
		CMD
		ul->t1
		ul->t2
		
	THREAD2
		l->t1
		l->t2
		CMD
		ul->t1
		ul->t2
		
		
		NOT: Arkaya arkaya aynı mutex'i lock yaparsak yine deadlock'a gireriz. Bu durumunda bir çözümü vardır ama mutex'e attribute geçerek bu sorunu ortadan kaldırabiliriz.
		
		
9-)MUTEX ATTRIBUTES

	-> Default özellikler kullanmak istemiyorsak muetex_init'e özellikleri belirledikten sonra attribut'un addresini geçmemiz lazım.
	
	pubs.opengroup.org sitesinden pthread_mutexattr_settype(); fonksiyonuna geçilecek parametreleri buradan bakabilirsin.
	
	*-*int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict attr,
       int *restrict type); (başarı durumunda 0, başarısız hata kodu)
	*-* int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type); (başarı durumu 0 başarısız hata kodu)
	
	NOT: pthread_mutex_init(&mutex,NULL); //buradaki attribute 2 farklı process'in thredleri arasında bu mutex'i kullanabilmek içinde kullanılır.
	
	mesela yukarıda arka arkaya aynı mutex'i lock yapmıştık, burada PTHREAD_MUTEX_RECURSIVE macrosunu attribute olarak ayarlarsak buradaki deadlock sorunu çözülmüş olacak.
	
	"!!!NOT: Örnek kod thread3 dosyasında verilmiştir."
	
	örn;
	pthread_mutexattr_t mutex_attr;	//mutex'i init etmeden önce attribut'u ayarlarız.
	pthread_mutexattr_init(&mutex_attr);
	pthread_mutexattr_settype(&mutex_attr,PTHREAD_MUTEX_RECURSIVE);
	pthread_mutex_init(&mutex1,&mutex_attr);
	
	
	işimiz bittikten sonra destroy ederiz
	
	pthread_mutex_destroy(&mutex1);
	pthread_mutexattr_destroy(&mutex_attr);
	
	!!!NOT!!! = RECURSIVE MUTEXLERDE KAÇ KERE LOCK YAPTIYSAK O KADAR UNLOCK YAPMAMIZ GEREKIR AKSI TAKIRDE PROBLEM CIKARACAKTIR!!!
	
	
10-)CONDITIONAL VARIABLE(Yeni bir senkronizasyon nesnesi)
	
	->BİR THREAD VAR BİR İŞ YAPILDIKTAN SONRA İŞİN DEVAM ETMESİNİ İSTİYORSAK VE O İŞİ BAŞKA BİR THREAD YAPIYORSA CONDITIONAL VARIABLE BU DURUMLARDA KULLANILIR.
	
	!!!NOT!!!: Mutexlerle beraber kullanılır.
	
	!!!NOT: örn kod thread3 dosyasında
	
	örn; 			
	T1			T2
	cmd			cmd
	cmd			cmd
	sart-----------	
x)	cmd	      |-------> sart //sart tamamlanırsa akıs T1 de x den devam eder.
	cmd			cmd
	
	->bir thread bir thred'i bir olay olana kadar beklemesini istediğimiz durumlarda ve olay tamamlandıktan sonra akışın devam etmesini istiyorsak şart tamamlanmazsa thread wait kuyruğuna geçer. örnek senaryo porttan veri bekliyoz soketten okuma işlemi gerçekleşti ve diğer thread veriyi  okuyup işlemeye başlayabilir.
	 	
		 *-* int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr); (başarı 0 başarısız hata kodu)
		 *-* pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
		 *-* int pthread_cond_wait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex);	(başarı 0 başarısız hata kodu) //mutex'in kilidini açacaktır.
		 *-* int pthread_cond_destroy(pthread_cond_t *cond); (başarı 0 başarısız error number)
		 *-* int pthread_cond_signal(pthread_cond_t *cond); (başarı 0 başarısız error number)	//bir thread'i uyandıracak ama birden fazla thread'ide uyandırabilir.yani en az 1 thread'i uyandırma garantisinde bulunuyor. KONTROLLU KULLANACAZ ISTENMEYEN THREADLER UYANABILIR. TEK BIR THREAD VARSA SIKINTI OLMAYACAKTIR.
		 
		 !!!NOT: işlemler tamamlandıktan sonra cond ve mutex destroy edilmeli.
		 !!!NOT: örnekte while kullanılmasının sebebi sahte uyandırmaları önlemek için.Yani şart sağlanamadan uyanmış mı uyandırılmamış mı onu kontrol etmek için.
		 !!!NOT: CONDITIONAL VARIABLE THREAD'LERIN ILISKILI OLDUGU DURUMLARDA KULLANILACAK
		 
		 
		 
 	ALT BASLIK-) BROADCAST OLAYI
 	
 		->cond_signal contaxt switch aşamasında herhangi bir thread'i uyandırabilir. en az 1 thread uyandıracağını garanti ediyor bu 1 de olabilir 2 de
 		
 		*-* int pthread_cond_broadcast(pthread_cond_t *cond); (başarı 0 başarısız hata kodu)(ilgili thread'lerin tümüne sinyal gönderir, broadcast pakete benzer) örn; write yapan thread var ve read yapan bir kaç thread broadcast kullanarak write tamamlandıktan sonra read yapan bütün görevleri bilgilendiriyoruz. asyncron threadlerde cond_signal kullanmak iyi bir yöntem değil sanırım.
 		
 		!!!NOT: threadleri ayrı ayrı kullanmak istiyorsak cond_signal kullanıp flaglerle oynamamız gerekecektir.
 		
 		
 		!!!NOT: cond_broadcast ve cond_signal CONDITIONAL VARIABLE ILE BLOCKLANMIŞ THREADLERE SINYAL GONDERIR!!!
		 
	
11-)SEMAPHORE
	
	->sayaca sahip senkronizasyon, mesela bir kısma 3 tane thread girebilsin istiyorsak semaphore kullanırız. Semaphore sayacı neyse aynı anda o kadar thread girebilir demek.
	
	PRODUCER->Uretici thread , CONSUMER->tüketici thread
	
	NOT:sistem semaphor ları yerine possix semaphor larını ele alacağız
	
	#include <semaphore.h>
	
	sem_t semaphore_x;
	
	*-* int sem_init(sem_t *sem, int pshared, unsigned value); (başarı 0 başarısız -1(set for errno)) (pshared 1-> processler arası paylaşım enable 0 disable, value->semapore sayacının kaçtane olduğunu belirtir ve aynı anda o kadar thread girebilir.)
	
	*-* int sem_trywait(sem_t *sem);
	*-* int sem_wait(sem_t *sem); (başarı 0, başarısız -1(set errno indicate error.)) (critic koda girerken kullanılan fonksiyon semaphore sayıcını kontrol eder 0 dan farklıysa girer ve semaphore 1 azaltılır.)
	
	*-* int sem_post(sem_t *sem); (başarı 0, başarısız -1(set errno indicate error.)) (critic koddan çıkarken kullanılır ve semaphore sayacını 1 arttırır.)
	
	*-* int sem_destroy(sem_t *sem); (başarı 0, başarısız -1(set errno indicate error.)) (semaphore u destroy eder.)
	
	örn;
	
		sem_wait();
		cmd
		cmd
		sem_post();
		cmd
		...
		
		
	!!!NOT: TUM THREADLER AYNI ANDA GIRIYOR!!!
	
	
	
	ALT BASLIK-) PRODUCER_CONSUMER
	
	->ortak kullanılan bir buffer var ve buffer'ı daha hızlı çalışması bir taraftan değer üretiliyor bir taraftan tüketiliyor.
	
	->üretici tüketici problemlerinde genelde semaphore kullanılır. BUNUDA 
	 SEMAPHORE KULLANARAK YAPARIZ(SEMAPHORE LARI ÇAPRAZLAMA KULLANACAĞIZ).
	 
	 !!!NOT: örnek kod thread5-consumer-producer dosyasında ODEV OLSUN
	 
	 !!!NOT: Aynı yeri kullanan threadler varsa Mutex kullanmak lazım
	 
 
 12-) READER_WRITER LOCKS (OKUMA YAZMA KILITLERI)
 
 	->Yeni bir senkronizasyon nesnesi, mutexlere benziyor ama mutexlerden biraz farklı olacak.
 	
 	-> !!!mutexte lock yaptık unlock yapana kadar, critical sectiona hiç kimse giremez. thread1 lock yaptı thread2 unlock yapamaz mutex böyle bir senkronizasyon nesnesi değil çünkü.
 	
 	
 	-> çok büyük bir array imiz var diyelim örnek olarak 10 diyelim anlaması kolay olsun
 	ilk 5 elemanı 1 threade son 5 elemanı bir thred'e okutarak daha performanslı bir okuma sağlayabiliriz. Yada 2 thred'in bir buffer'ı serch etmesini sağlayabiliriz.
 	
 	->veri yapılarında okuma yazma işlemleri yaparken çok işimize yarayabilir.
 	
 	*-* int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
	*-* int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,const pthread_rwlockattr_t *restrict attr);
	*-* pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;
	
	*-* int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
	*-* int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
	
	*-* int pthread_rwlock_rwlock(pthread_rwlock_t *rwlock);
	*-* int pthread_rwlock_tryrwlock(pthread_rwlock_t *rwlock);		
		--Bu aralığı critic kodları yazmak için kullanacağız.
	*-* int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
	
	->yazma amaçlı veya okuma amaçlı critic code.
	(Yukarıda belirtilen fonk.'lar Başarı durumunda 0 , başarısızlık ERROR_NUMBER)
 
 	örn;
 		read_lock yapıldıysa yazma amaçlı threadler rwlock_t nesnesini alamaz ama okuma amaçlı threadler critical section'ı execute edebilir.Bu şekile birden fazla thread'e read veya write yaptırarak daha fazla zaman kazanmış oluyoruz sanırım. 
 	
 		
 		
13-)BARRIER OBJECT

	->yeni bir senkronizasyon nesnesi daha
	
	->barire'i init ederken 3 geçersek, 3 tane thread bu noktaya ulaşınca akışın devam edeceği anlamına gelir. 3. thread bu noktaya ulaştığında akış threadler için devam edecektir.
	
	->kullanım senaryoları; bu iç thread bir işin parçası olabilir ve bir noktaya ulaştıktan sonra işin devam etmesi gerekiyorsa barier object kullanmamız lazım.
	 Yani 3 thread'inde o noktaya ulaşması lazım.
	 
	 çok büyük sayıda sort edilecek sayımız olsun (örn 300k) 1.thread 100k yı 2.thread 100k 3.thread 100k sonra akışa devam.
	 
	 *-* pthread_barrier_t g_barrier;	//static initializer macrosu yok.
	 *-* int pthread_barrier_destroy(pthread_barrier_t *barrier);
	 *-* int pthread_barrier_init(pthread_barrier_t *restrict barrier,
const pthread_barrierattr_t *restrict attr, unsigned count); (count o kadar thread'de akış devam etmesi için.)
	*-* int pthread_barrier_wait(pthread_barrier_t *barrier); (bu kısma gelince sayaç 1 artar.)
	
	(Yukarıda belirtilen fonk.'lar Başarı durumunda 0 , başarısızlık ERROR_NUMBER
	
	!!!NOT: barrier_wait icin MESELA BARRIER COUNTER = 4 BASARI DURUMUNDA SAYAC 4'E ULASINCA THREADLERDEN BIRI "PTHREAD_BARRIER_SERIAL_THREAD" MACROSUNUN DEGERINI DONDURUR.YANI 3 THREAD'de wait fonksiyonu 0 döndürecek 1 threadde belirtilen macro değerini) 
	PEKI NEDEN BU MACRO DEGERI DONUYOR-> BIR THREAD'IN SPESIFIK BIR IS YAPMASINI ISTEYEBILIRIZ,AMA HANGISI OLDUGU BELLI DEGIL BIZDE BU MACRO DONDUYSE THREAD_X(herhangi bir thread) SPESIK BIR IS YAPSIN DIYEBILIRIZ VEYA BU MACROYLA DONEN THREAD SPESIFIK BIR IS YAPSINDA DIYEBILIRIZ.
	
	!!!NOT: main scope'ta bir thread'tir yani belirtilen tüm multithread fonksiyonları main içinde kullanılabilir.
	
	
	
14-)SPINLOCK

	
	
	 
	



		
		
		

			
			
	
	
        
        
       
		
		
		
		
		
		
		


     	     	
     	     	
     	     	

